Task 1

Test the POST request to https://testpasswords.com. Write possible tests to verify testpasswords.com (should simulate real-world test coverage).

There are 2 requests:

Request 1:

    Method: POST

    URL: https://testpasswords.com

    Authentication: Basic Auth, login - 'login' and password - 'password'

    Request Body:
    JSON

    {
      "userName": "String",
      "newPassword": "String"
    }

Response 1:

    Response Body:
    JSON

{
  "userName": "String",
  "userLastName": "String",
  "userPhone": "String"
}

where userName is unknown (must be obtained from the GET request below), newPassword must be generated by a randomizer.

Response 2:
GET https: testusers.com&phone=phonenumber
Response:
{
  "name": "String",
  "lastname": "String"
}

where phonenumber is any phone number

Additional conditions:

    The POST to testpasswords.com and GET to testusers.com&phone=phonenumber must be called in one request.

    userName (from the POST request) = name (from the GET request).

    Write the response as follows:

    url
<some code>
body
<some code>
pre-request
<some code>
test
<some code>

Solution

url
https:testpasswords.com

Authorization
Basic Auth
login - ‘login’
password - ‘password’

body
{
    "userName": "{{$name}}",
    "newPassword": "{{$randomPassword}}"
}

pre-request
const postRequest = {
  url: 'https://testusers.com&phone=phonenumber',
  method: 'GET'
};
pm.sendRequest(postRequest, function (err, response) {
    var jsonDataPreRequest = pm.response.json();


pm.test("Check type of name", function() {
pm.expect(jsonDataPreRequest.name).to.be.a('string');
});
pm.test("Check type of lastname", function() {
pm.expect(jsonDataPreRequest.name).to.be.a('string');
});
pm.globals.set("name", jsonDataPreRequest.name );
pm.globals.set("lastname", jsonDataPreRequest.lastname);
});


pm.variables.replaceIn('{{$randomPassword}}');


test
pm.test("Status code is 200 / test AUTH", function () {
    pm.response.to.have.status(200);
});


var jsonData = pm.response.json();
pm.test("Check userName", function () {
        pm.expect(jsonData.userName).to.eql(pm.globals.get("name"));
});
pm.test("Check userName", function () {
        pm.expect(jsonData.userLastName).to.eql(pm.globals.get("lastname"));
});
pm.test("Check type of userName", function() {
pm.expect(jsonData.userName).to.be.a('string');
});
pm.test("Check type of userLastName", function() {
pm.expect(jsonData.userLastName).to.be.a('string');
});
pm.test("Check type of userPhone", function() {
pm.expect(jsonData.userPhone).to.be.a('string');
});


Task 2

Write tests (must simulate real-world test coverage for this case) to check the title, description, 
and status for a specific transactionId that is already saved in our Global variable as currentTransactionId. 

You need to parse the JSON and find a specific object by its values to write the tests.


{
  "data": {
    "total": 10,
    "items": [
      {
        "id": "GUID_1",
        "userId": "userIdGUID",
        "type": "TRANSACTION",
        "title": "Title_1",
        "description": "Description_1",
        "data": {
          "transactionId": "transactionIdGUID",
          "cardId": "cardIdGUID",
          "status": "FINISHED",
          "category": "P2P"
        },
        "date": "2022-06-22T10:10:03.000Z"
      },
      ...
      {
        "id": "GUID_10",
        "userId": "userIdGUID",
        "type": "TRANSACTION",
        "title": "Title_10",
        "description": "Description_10",
        "data": {
          "transactionId": "transactionIdGUID",
          "cardId": "cardIdGUID",
          "status": "FINISHED",
          "category": "P2P"
        },
        "date": "2022-06-20T10:10:03.000Z"
      }
    ]
  }
}

// Solution 

{
    var jsonData = pm.response.json();
const object = jsonData.data.items.data.filter(({ transactionId }) => transactionId === pm.globals.get("currentTransactionId"));


pm.test("Check title", function () {
pm.expect(object.title).to.eql(“Title_1”);
};
pm.test("Check description", function () {
pm.expect(object.description).to.eql(“Description_1”);
};
pm.test("Check title", function() {
pm.expect(object.data.status).to.eql(“FINISHED”);
};


pm.test("Check type of title", function () {
pm.expect(object.title).to.be.a('string');


};
pm.test("Check type of description", function () {
pm.expect(object.description).to.be.a('string');


};
pm.test("Check type of status", status() {
pm.expect(object.data.status).to.be.a('string');
};
}

Task 3
Validate the incoming (response) JSON against a schema for this JSON using scripts in Postman.

{
  "data": {
    "sessionId": "GUID",
    "key": "GUID"
  }
}

Solution

const schema = {
  "$schema": "http://json-schema.org/draft-04/schema#",
  "type": "object",
  "properties": {
    "data": {
    "type": "object",
    "properties": {
        "sessionId": {
        "type": "string"
        },
        "key": {
        "type": "string"
        }
    },
    "required": [
        "sessionId",
        "key"
    ]
    }
  },
  "required": [
    "data"
  ]
};
pm.test("Validating schema", (){
    pm.response.to.have.jsonSchema(schema);
});


Task 4
In a pre-request script, get the URL and query, assign them to a global variable, and overwrite it using globals.replaceIn when this variable is called.

Example for URL: GET https://users/params&userName=name1

Solution
{
pm.globals.set("url", "https://users/params&userName=name1");
const query = "?queryKey=queryValue";
const urlWithQuery = pm.globals.replaceIn(pm.globals.get("url") + query);
}


Task 5
Using JavaScript, create and populate an array of objects.

To populate, use:
const capitalArray = ['Tokyo', 'Paris', 'Kyiv', 'London']

The new array should contain objects of the type:
{'country': 'String', 'capital': 'String'}

Solution

const capitalArray  = [ 'Tokio','Paris','Kyiv','London' ];
const countryArray = ['Japan', 'France', 'Ukraine', 'England'];
const result = [];


for (var i = 0 ; i < capitalArray.length; i++) {
result.push({capital: capitalArray[i], country:countryArray[i]})
};
console.log(result);

Task 6
Create a method that can find a nested object within an object by a parameter and return only that object.

Input Parameter:

{
  "user1": {
    "name": "name1",
    "phone": "phone1"
  },
  "user2": {
    "name": "name2",
    "phone": "phone2"
  },
  "user3": {
    "name": "name3",
    "phone": "phone3"
  }
}
Output parameter: any object from the object above that will be found by name or phone.


Solution
{
var jsonData = pm.response.json();
var name = “name2”;
const object = jsonData.filter(({ name}) => name === name);
}
OR
{ 
var jsonData = pm.response.json();
var phone = “phone2”
const object = jsonData.filter(({ phone}) => phone === phone);
}

Task 7
Write a method that replaces invalid characters in a text.

Input parameter: a text that contains the symbols %, !, and ?.
Output parameter: the text without the symbols %, !, and ?.

Solution 

const mystring = "String!? 100%";
mystring.replace(/[!%?]/g, '');
